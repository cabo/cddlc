#!/usr/bin/env ruby
require 'pp'
require 'yaml'
require 'treetop'
require 'json'

require_relative '../lib/cddlc.rb'

def named_keys(tree)
  # warn [:T, tree].inspect
  fail unless Array === tree
  case tree[0]
  when "seq", "gcho", "tcho"
    tree[1..-1].flat_map {|x| named_keys(x)}
  when "rep"
    named_keys(tree[3])
  when "mem"
    key = tree[1]
    if Array === key && key[0] == "name"
      [key[1]]
    end
  end || []
end

def integer_value(tree)
  tree and (
    fail tree.inspect unless Array === tree
    case tree[0]
    when "number"
      tree[1]
      # XXX: could add other cases
    end
  )
end

def snaky(name)
  name.gsub(/-/, "_")
end
 
Encoding.default_external = Encoding::UTF_8
require 'optparse'
require 'ostruct'

$options = OpenStruct.new
begin
  op = OptionParser.new do |opts|
    opts.banner = "Usage: cddlc.rb [options] file.cddl"

    opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
      $options.verbose = v
    end
    opts.on("-r", "--[no-]rules", "Process rules") do |v|
      $options.rules = v
    end
    opts.on("-x", "--[no-]expand", "Expand generics") do |v|
      $options.expand_generics = v
    end
    opts.on("-u", "--[no-]undefined", "Note undefined names") do |v|
      $options.note_undefined = v
    end
    opts.on("-2", "--[no-]cddl2", "Perform some CDDL 2.0 processing") do |v|
      $options.cddl2 = v
    end
    opts.on("-tFMT", "--to=FMT", [:basic, :neat, :json, :yaml, :enum, :cddl], "Target format") do |v|
      $options.target = v
    end
  end
  op.parse!
rescue Exception => e
  warn e
  exit 1
end

if ARGV == []
  puts op
  exit 1
end
cddl_file = ARGF.read

cddl = CDDL.from_cddl(cddl_file)
result = if $options.rules
           if $options.expand_generics
             require_relative "../lib/processor/cddl-expander.rb"
             cddl.expand_generics
           end
           cddl.rules
         else
           warn "** can't expand in tree; use -r flag as well" if $options.expand_generics
           cddl.tree
         end

warn "** can't note undefined for target != cddl" if $options.note_undefined && $options.target != :cddl

if $options.cddl2
  require_relative '../lib/processor/cddl-undefined.rb'
  directives = cddl_file.lines.grep(/^;# /).map(&:chomp).map{|l| l.sub(/^;#\s+/, '')}
  # puts "** Directives: <<"
  # puts directives
  directives.each do |di|
    case di
    when /\Ainclude\s+([-._a-zA-Z0-9]+)(?:\s+as\s+([-._a-zA-Z0-9]+))?\s*\z/
      docref = $1
      explicit_preferred_tag = $2
      preferred_tag = explicit_preferred_tag || docref
      puts "PREFERRED_TAG #{preferred_tag}" if $options.verbose
      puts "DOCREF #{docref}" if $options.verbose
      fn = docref.downcase << ".cddl"
      io = File.open(fn) rescue File.open(CDDL::DATA_DIR + fn) # XXX CDDL_PATH
      include_file = io.read
      # XXX: processing directives recursively!
      included_cddl = CDDL.from_cddl(include_file)
      # XXX: Should namespace that thing now! all names -> preferred_tag.name
      p included_cddl.rules.keys
      # XXX: do once, first, to rename COSE_Key to RFC9052.COSE_Key
      loop do
        undef_rule, _undef_gen = cddl.cddl_undefined # ignore undef_gen for now
        # p undef_rule
        got_more = false
        undef_rule.each do |name|
          if rule = included_cddl.rules[name]
            cddl.rules[name] = rule                     # XXX must be namespaced!
            puts "IMPORTED #{name} from #{fn}" # ...: #{rule}... if $options.verbose
            got_more = true
          end
        end
        break unless got_more
      end
    else
      warn "** unknown directive '#{di}' ignored"
    end
  end
end

case $options.target
when :basic, nil
  pp result
when :neat, :json
  require 'neatjson'
  puts JSON.neat_generate(result, after_comma: 1, after_colon: 1)
when :yaml
  puts result.to_yaml
when :enum
  rules = cddl.rules
  rules.each do |k, v|
    if v[0] == "map"
      nk = v[1..-1].flat_map {|e| named_keys(e)}
      # warn [:NK, k, nk].inspect
      nk = nk.map {|name| i = integer_value(rules[name]); [name, i] if i}.compact
      # warn [:NK, k, nk].inspect
      if nk != []
        puts "enum #{snaky(k).downcase}_keys {"
        nk.each do |n, v|
          puts "  #{snaky(n).upcase} = #{v},"
        end
        puts "};"
      end
    end
  end
when :cddl
  require_relative '../lib/writer/cddl-writer.rb'
  if $options.note_undefined
    require_relative '../lib/processor/cddl-undefined.rb'
    undef_rule, undef_gen = cddl.cddl_undefined
    undef_rule.each do |k|
      puts ";;; *** undefined: #{k}"
    end
    undef_gen.each do |k|
      puts ";;; *** undefined: #{k}<>"
    end
  end
  puts cddl.to_s
else
  warn ["Unknown target format: ", $options.target].inspect
end

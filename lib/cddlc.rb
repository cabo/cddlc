require_relative "parser/cddl-util.rb"
require_relative "processor/cddl-visitor.rb"
require_relative 'processor/cddl-undefined.rb'
require_relative 'writer/cddl-writer.rb'

class CDDL
  @@parser = CDDLGRAMMARParser.new

  DATA_DIR = Pathname.new(__FILE__) + "../../data/"
  # empty string is for CDDL::DATA_DIR
  CDDL_INCLUDE_PATH = ENV["CDDL_INCLUDE_PATH"] || ".:"

  def self.cddl_include_path
    CDDL_INCLUDE_PATH.split(":", -1).map {_1 == "" ? CDDL::DATA_DIR : Pathname.new(_1)}
  end

  def self.reason(parser, s)
    reason = [parser.failure_reason]
    parser.failure_reason =~ /^(Expected .+) after/m
    reason << "#{$1.gsub("\n", '<<<NEWLINE>>>')}:" if $1
    if line = s.lines.to_a[parser.failure_line - 1]
      reason << line
      reason << "#{'~' * (parser.failure_column - 1)}^"
    end
    reason.join("\n")
  end

  # (keeps only renamed rules)
  def rename(rename_map)
    rules.replace(
      Hash[rename_map.map do |o, n|
             [n, visit(rules[o]) do |prod|
                case prod
                in ["name", *] | ["gen", *]
                  prod[1] = rename_map[prod[1]] || prod[1]
                else
                end
                false
              end]
           end])
  end

  def self.read_from_include_path(fn)
    io = nil
    CDDL::cddl_include_path.each do |path|
      begin
        io = (path + fn).open
        break
      rescue Errno::ENOENT
        next
      end
    end
    io
  end

  SAFE_FN = /\A[-._a-zA-Z0-9]+\z/
  IMPINC = /\A(?:import|include)\z/
  IDENTIFIER_RE = /\A[A-Za-z@_$]([-.]*[A-Za-z@_$0-9])*\z/
  INT_RE = /\A0|[-]?[1-9][0-9]*\z/

  def self.from_cddl(s)
    ast = @@parser.parse s
    if !ast
      fail self.reason(@@parser, s)
    end
    if $options.cddl2
      directives = s.lines.grep(/^;# /).map(&:chomp).map{|l| l.sub(/^;#\s+/, '').split(/\s+/)}
      # puts directives.to_yaml
    end

    ret = CDDL.new(ast, directives)

    if $options.cddl2
      ret.perform_directives
    end
    ret
  end

  def perform_directives
    directives.each do |di|
      preferred_tag = nil
      from = nil
      case di
      in [IMPINC => dir, SAFE_FN => docref, "as", SAFE_FN => preferred_tag]
      in [IMPINC => dir, SAFE_FN => docref]
      in [IMPINC => dir, *from, "from", SAFE_FN => docref, "as", SAFE_FN => preferred_tag]
      in [IMPINC => dir, *from, "from", SAFE_FN => docref]
      else
        warn "** Can't parse directive »#{di.join(" ")}«"
        next
      end
      if from
        from = from.map do |name|
          name.chomp!(",")
          if IDENTIFIER_RE === name
            name
          else
            warn "*** invalid identifier #{name.inspect} ignored in »#{di.join(' ')}«"
            nil
          end
        end.compact
      end
      warn "FROM #{from.inspect}" if $options.verbose
      warn "PREFERRED_TAG #{preferred_tag.inspect}" if $options.verbose
      warn "DOCREF #{docref.inspect}" if $options.verbose

      fn = docref.downcase << ".cddl"
      io = CDDL.read_from_include_path(fn)
      unless io
        warn "** #{dir} file #{fn} not found in #{CDDL::cddl_include_path.map(&:to_s)}"
        next
      end

      include_file = io.read
      included_cddl = CDDL.from_cddl(include_file)
      if preferred_tag
        included_cddl = included_cddl.deep_clone # needed?
        renamed_names = included_cddl.rules.keys
        name_rename = Hash[
          renamed_names.map { |o|
            n = "#{preferred_tag}.#{o}"
            warn "** Warning: renamed name #{n} already in #{fn}" if included_cddl.rules[n]
            [o, n]}]
        included_cddl.rename(name_rename)
      end

      case dir
      in "import"
        warn "** IMPORTING #{from && from.join(", ") << " from "}#{fn}" if $options.verbose

        must_be_found = false
        to_be_imported = if from
                           if preferred_tag
                             from.map{ |k|
                               if k =~ /\A#{preferred_tag}[.]/
                                 k
                               elsif nn = name_rename[k]
                                 if old = store_rule(k, v = ["name", nn])
                                   warn "*** autogenerated rule #{k} = #{v} would overwrite #{old}"
                                 end
                                 nn
                               else
                                 warn_error "*** imported rule #{k.inspect} not in #{fn}"
                               end
                             }.compact
                           else
                             must_be_found = true
                             from
                           end
                         else
                           cddl_undefined
                         end
        loop do
          # p to_be_imported
          got_more = false
          to_be_imported.each do |name|
            if rule = included_cddl.rules[name]
              rules[name] = rule
              warn "IMPORTED #{name} from #{fn}" if $options.verbose
              got_more = true
            elsif must_be_found
              warn_error "*** imported rule #{name.inspect} not in #{fn}"
            end
          end
          break unless got_more
          recently_imported = to_be_imported
          to_be_imported = cddl_undefined # XXX square...
          warn "TO IMPORT #{to_be_imported.inspect}" if $options.verbose
          if to_be_imported == recently_imported
            fail "No progress importing #{to_be_imported.inspect} from #{fn} (generics issue?)"
          end
          must_be_found = false
        end
        if preferred_tag
          to_be_imported.each do |name|
            warn "** Warning: undefined reference #{name} without namespace prefix is defined in namespaced imported module #{fn}" if name_rename[name]
            ### instead just add rule...
          end
        end
      in "include"
        if from
          from = Set[*from]
        end
        warn "** INCLUDING #{from && from.join(", ") << " from "}#{fn}" if $options.verbose
        included_cddl.rules.each do |k, v|
          if from
            next unless from.include?(k)
            from.delete(k)
          end
          if old = store_rule(k, v)
            warn "*** included rule #{k} = #{v} would overwrite #{old}"
          end
        end
        if from && !from.empty?
          warn "*** could not find #{from.join(", ")} in #{fn}"
        end
      end
    end
  end

  RULE_OP_TO_CHOICE = {"/=" => ["tcho", "tadd"], "//=" => ["gcho", "gadd"]}
  CHOICERULES = RULE_OP_TO_CHOICE.values.flatten
  RULE_OUTER_TO_CHOICE = {"tadd" => ["tcho", "tadd"], "gadd" => ["gcho", "gadd"]}

  def store_rule(k, v)
    if old = rules[k]
      if old != v
        if cho = RULE_OUTER_TO_CHOICE[v[0]]
          merge_to_rule(k, v, cho)
        else
          return old              # error
        end
      end
    else
      rules[k] = v
    end
    nil                         # OK
  end

  def warn_error(s)
    warn s
    @error = true
  end

  attr_accessor :ast, :tree, :directives
  def initialize(ast_, directives_ = [])
    @ast = ast_
    @tree = ast.ast
    @rules = nil                # only fill in if needed
    @directives = directives_
  end

  def deep_clone
    Marshal.load(Marshal.dump(self))
  end

  def merge_to_rule(name, val, cho)
        @rules[name] = nv =
          if (old = @rules[name]) && old != val
            fail "overwriting #{write_rule(name, old)} ...with... #{write_rule(name, val)}" unless cho
            if Array === old && cho.include?(old[0])
              if cho.include?(val[0])
                old.dup.append(*val[1..-1])
              else
                old.dup << val
              end
            else
              #  can't put an old "g/tadd" into a new "t/gcho"
              fail "can't add #{write_rule(name, [cho[1], val])} ...to... #{write_rule(name, old)}" if CHOICERULES.include?(old[0])
              [cho[0], old, val] # old might need to be packaged for gcho
            end
          else
            if cho
              if val[0] == cho[0]
                [cho[1], *val[1..-1]]
              else
                [cho[1], val]
              end
            else
              val
            end
          end
        if name[0..1] == "$$"
          check_socket(name, nv, "gadd", "tadd", "tcho", "type", "group")
        elsif name[0] == "$"
          check_socket(name, nv, "tadd", "gadd", "gcho", "group", "type")
        end
  end

  def rules
    if @rules.nil?              # memoize
      @rules = {}
      fail unless @tree.first == "cddl"
      @tree[1..-1].each do |x|
        op, name, val, rest = x
        cho = RULE_OP_TO_CHOICE[op]
        fail rest if rest
        fail name unless Array === name
        case name[0]
        when "name"
          fail unless name.size == 2
          name = name[1]
        when "gen"
          parmnames = name[2..-1]
          name = name[1]        # XXX update val with parm/arg
          val = ["parm", parmnames,
                 visit(val) do |p|
                   case p
                   in ["name", nm]
                     if ix = parmnames.index(nm)
                       [true, ["arg", ix]]
                     end
                   else
                     false
                   end
                 end]
        else
          fail name
        end
        merge_to_rule(name, val, cho)
      end
      # warn "** rules #{rules.inspect}"
    end
    @rules
  end

  def check_socket(name, nv, right, wrong, wrong_plain, wrong_kind, kind)
    unless nv[0] == right
      if nv[0] == wrong
        flaw = "#{wrong_kind} choice #{write_rhs([wrong_plain, *nv[1..-1]], 2.1)} in"
      else
        flaw = "plain assignment of #{write_rhs(nv, 2.1)} to"
      end
      warn "** warning: #{flaw} #{kind} socket #{name}"
    end
  end

  def prelude
    if @prelude.nil?
      @prelude = CDDL.from_cddl(File.read(DATA_DIR + "prelude.cddl"))
    end
    @prelude
  end

  # In each specific case, use the appropriate subset
  ESCAPED_STRING_MAPPINGS = Hash[[
                                   ["\x08", "b"],
                                   ["\x09", "t"],
                                   ["\x0A", "n"],
                                   ["\x0C", "f"],
                                   ["\x0D", "r"],
                                   ["\x22", "\""],
                                   ["\x27", "'"],
                                   ["\x2F", "/"],
                                   ["\x5C", "\\"],
                                 ]]

  # TODO: Enable selecting Unicode-friendly variants
  def escape_string(s, regexp = /[^\n !#-\[\]-~]/)
    s.gsub(regexp) {|ch|
      if m = ESCAPED_STRING_MAPPINGS[ch]
        "\\#{m}"
      elsif (o = ch.ord) < 0x10000
        "\\u#{"%04x" % o}"
      else
        "\\u{#{"%x" % o}}"
      end
    }
  end

  def escape_byte_string(s)
    escape_string(s, /[^\n -&(-\[\]-~]/)
  end

  def bytes_escaped(tesc, t)
    if tesc.nil?
      case t
      in ["", text]
        "'" + escape_byte_string(text)
      in [/\Ah\z/i, text]
        "h'" + escape_byte_string(text)
      in [/\Ab64\z/i, text]
        "b64'" + escape_byte_string(text)
      # else error
      end + "'"
    else
      tesc
    end
  end

end

require_relative "parser/cddl-util.rb"
require_relative "processor/cddl-visitor.rb"
require_relative 'processor/cddl-undefined.rb'

class CDDL
  @@parser = CDDLGRAMMARParser.new

  DATA_DIR = Pathname.new(__FILE__) + "../../data/"
  # empty string is for CDDL::DATA_DIR
  CDDL_INCLUDE_PATH = ENV["CDDL_INCLUDE_PATH"] || ".:"

  def self.cddl_include_path
    CDDL_INCLUDE_PATH.split(":", -1).map {_1 == "" ? CDDL::DATA_DIR : Pathname.new(_1)}
  end

  def self.reason(parser, s)
    reason = [parser.failure_reason]
    parser.failure_reason =~ /^(Expected .+) after/m
    reason << "#{$1.gsub("\n", '<<<NEWLINE>>>')}:" if $1
    if line = s.lines.to_a[parser.failure_line - 1]
      reason << line
      reason << "#{'~' * (parser.failure_column - 1)}^"
    end
    reason.join("\n")
  end

  # (keeps only renamed rules)
  def rename(rename_map)
    rules.replace(
      Hash[rename_map.map do |o, n|
             [n, visit(rules[o]) do |prod|
                case prod
                in ["name", *] | ["gen", *]
                  prod[1] = rename_map[prod[1]] || prod[1]
                else
                end
                false
              end]
           end])
  end

  def self.read_from_include_path(fn)
    io = nil
    CDDL::cddl_include_path.each do |path|
      begin
        io = (path + fn).open
        break
      rescue Errno::ENOENT
        next
      end
    end
    io
  end

  SAFE_FN = /\A[-._a-zA-Z0-9]+\z/
  IMPINC = /\A(?:import|include)\z/
  IDENTIFIER_RE = /\A[A-Za-z@_$]([-.]*[A-Za-z@_$0-9])*\z/
  INT_RE = /\A0|[-]?[1-9][0-9]*\z/

  def self.from_cddl(s)
    ast = @@parser.parse s
    if !ast
      fail self.reason(@@parser, s)
    end
    if $options.cddl2
      directives = s.lines.grep(/^;# /).map(&:chomp).map{|l| l.sub(/^;#\s+/, '').split(/\s+/)}
      # puts directives.to_yaml
    end

    ret = CDDL.new(ast, directives)

    if $options.cddl2
      ret.perform_directives
    end
    ret
  end

  def perform_directives
    directives.each do |di|
      preferred_tag = nil
      from = nil
      case di
      in [IMPINC => dir, SAFE_FN => docref, "as", SAFE_FN => preferred_tag]
      in [IMPINC => dir, SAFE_FN => docref]
      in [IMPINC => dir, *from, "from", SAFE_FN => docref, "as", SAFE_FN => preferred_tag]
      in [IMPINC => dir, *from, "from", SAFE_FN => docref]
      else
        warn "** Can't parse directive »#{di.join(" ")}«"
        next
      end
      if from
        from = from.map do |name|
          name.chomp!(",")
          if IDENTIFIER_RE === name
            name
          else
            warn "*** invalid identifier #{name.inspect} ignored in »#{di.join(' ')}«"
            nil
          end
        end.compact
      end
      warn "FROM #{from.inspect}" if $options.verbose
      warn "PREFERRED_TAG #{preferred_tag.inspect}" if $options.verbose
      warn "DOCREF #{docref.inspect}" if $options.verbose

      fn = docref.downcase << ".cddl"
      io = CDDL.read_from_include_path(fn)
      unless io
        warn "** #{dir} file #{fn} not found in #{CDDL::cddl_include_path.map(&:to_s)}"
        next
      end

      include_file = io.read
      included_cddl = CDDL.from_cddl(include_file)
      if preferred_tag
        included_cddl = included_cddl.deep_clone # needed?
        renamed_names = included_cddl.rules.keys
        name_rename = Hash[
          renamed_names.map { |o|
            n = "#{preferred_tag}.#{o}"
            warn "** Warning: renamed name #{n} already in #{fn}" if included_cddl.rules[n]
            [o, n]}]
        included_cddl.rename(name_rename)
      end

      case dir
      in "import"
        warn "** IMPORTING #{from && from.join(", ") << " from "}#{fn}" if $options.verbose

        must_be_found = false
        to_be_imported = if from
                           if preferred_tag
                             from.map{ |k|
                               if k =~ /\A#{preferred_tag}[.]/
                                 k
                               elsif nn = name_rename[k]
                                 if old = store_rule(k, v = ["name", nn])
                                   warn "*** autogenerated rule #{k} = #{v} would overwrite #{old}"
                                 end
                                 nn
                               else
                                 warn_error "*** imported rule #{k.inspect} not in #{fn}"
                               end
                             }.compact
                           else
                             must_be_found = true
                             from
                           end
                         else
                           cddl_undefined
                         end
        loop do
          # p to_be_imported
          got_more = false
          to_be_imported.each do |name|
            if rule = included_cddl.rules[name]
              rules[name] = rule
              warn "IMPORTED #{name} from #{fn}" if $options.verbose
              got_more = true
            elsif must_be_found
              warn_error "*** imported rule #{name.inspect} not in #{fn}"
            end
          end
          break unless got_more
          recently_imported = to_be_imported
          to_be_imported = cddl_undefined # XXX square...
          warn "TO IMPORT #{to_be_imported.inspect}" if $options.verbose
          if to_be_imported == recently_imported
            fail "No progress importing #{to_be_imported.inspect} from #{fn} (generics issue?)"
          end
          must_be_found = false
        end
        if preferred_tag
          to_be_imported.each do |name|
            warn "** Warning: undefined reference #{name} without namespace prefix is defined in namespaced imported module #{fn}" if name_rename[name]
            ### instead just add rule...
          end
        end
      in "include"
        if from
          from = Set[*from]
        end
        warn "** INCLUDING #{from && from.join(", ") << " from "}#{fn}" if $options.verbose
        included_cddl.rules.each do |k, v|
          if from
            next unless from.include?(k)
            from.delete(k)
          end
          if old = store_rule(k, v)
            warn "*** included rule #{k} = #{v} would overwrite #{old}"
          end
        end
        if from && !from.empty?
          warn "*** could not find #{from.join(", ")} in #{fn}"
        end
      end
    end
  end

  def store_rule(k, v)
    if old = rules[k]
      if old != v
        return old              # error
      end
    else
      rules[k] = v
    end
    nil                         # OK
  end

  def warn_error(s)
    warn s
    @error = true
  end

  attr_accessor :ast, :tree, :directives
  def initialize(ast_, directives_ = [])
    @ast = ast_
    @tree = ast.ast
    @rules = nil                # only fill in if needed
    @directives = directives_
  end

  def deep_clone
    Marshal.load(Marshal.dump(self))
  end


  RULE_OP_TO_CHOICE = {"/=" => ["tcho", "tadd"], "//=" => ["gcho", "gadd"]}
  CHOICERULES = RULE_OP_TO_CHOICE.values.flatten

  def rules
    if @rules.nil?              # memoize
      @rules = {}
      fail unless @tree.first == "cddl"
      @tree[1..-1].each do |x|
        op, name, val, rest = x
        cho = RULE_OP_TO_CHOICE[op]
        fail rest if rest
        fail name unless Array === name
        case name[0]
        when "name"
          fail unless name.size == 2
          name = name[1]
        when "gen"
          parmnames = name[2..-1]
          name = name[1]        # XXX update val with parm/arg
          val = ["parm", parmnames,
                 visit(val) do |p|
                   case p
                   in ["name", nm]
                     if ix = parmnames.index(nm)
                       [true, ["arg", ix]]
                     end
                   else
                     false
                   end
                 end]
        else
          fail name
        end
        @rules[name] =
          if (old = @rules[name]) && old != val
            fail "duplicate rule for name #{name} #{old.inspect} #{val.inspect}" unless cho
            if Array === old && cho.include?(old[0])
              old.dup << val
            else
              #  can't put an old "g/tadd" into a new "t/gcho"
              fail "can't add #{[cho[1], val]} to #{old}" if CHOICERULES.include?(old[0])
              [cho[0], old, val] # old might need to be packaged for gcho
            end
          else
            if cho
              if val[0] == cho[0]
                [cho[1], *val[1..-1]]
              else
                [cho[1], val]
              end
            else
              val
            end
          end
      end
      # warn "** rules #{rules.inspect}"
    end
    @rules
  end

  def prelude
    if @prelude.nil?
      @prelude = CDDL.from_cddl(File.read(DATA_DIR + "prelude.cddl"))

    end
    @prelude
  end
end
